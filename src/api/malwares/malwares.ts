import {feiOntologyEndpoint, owlEndpoint, rdfSchemaSyntax, xmlSchema} from "@/api/endpoints";
import {getName, getRelations, getSubtechniques} from "@/api/malwares/sparql";
import {Malware, MalwareClaim, MappedInfo} from "@/modules/malwares/store/malwaresStore";
import {DATA_SOURCES} from "@/util/consts/dataSources";

export const extractId = (uri: string, charToFind: string = '#') => {
    if (uri) {
        const hashtagIndex = uri.lastIndexOf(charToFind);
        return uri.substring(hashtagIndex + 1);
    }
    return '';
};

export const loadLabel = async(malwareId: string) => {
    return await getName(malwareId);
};

export const getClaim = (claims: [], property: string) => {
    if (property === malwarePropertyTypes.TYPE) {
        // @ts-ignore
        return extractId(claims.find((claim) => claim?.property?.includes(property))?.value) ?? '';
    }
    // @ts-ignore
    return claims.find((claim) => claim?.property?.includes(property))?.value?.slice(1, -1) ?? '';
};

export const parseProperties = (properties: any) => {
  return properties.map((property: any) => ({
    property: extractId(property.property),
    value: extractId(property.value)
  }));
};

export const omitTypes = [
    'string',
    'boolean'
];

export const getPlatformIcon = (platform: string): string => {
  switch (platform) {
      case 'macOS':
      case 'iOS':
          return 'app-macos';
      case 'Windows':
      case 'Office 365':
          return 'app-windows';
      case 'Azure AD':
          return 'app-azure';
      case 'Google Workspace':
          return 'app-google';
      case 'SaaS':
      case 'IaaS':
          return 'app-cloud';
      case 'Containers':
          return 'app-container';
      case 'Android':
          return 'app-android';
      default:
          return 'app-linux';
  }
};

export enum malwareClassesTypes {
    MITIGATION = 'Mitigation',
    TECHNIQUE = 'Technique',
    GROUP = 'Group',
    TACTIC = 'Tactic',
    SOFTWARE = 'Software'
}

export enum malwarePropertyTypes {
    TYPE = 'type',
    DOMAIN = 'domain',
    RANGE = 'range',
    MITIGATES = 'mitigates',
    HAS_DESCRIPTION = 'hasDescription',
    HAS_CONTRIBUTORS = 'hasContributors',
    HAS_DATA_SOURCES = 'hasDataSources',
    HAS_ID = 'hasId',
    HAS_NAME = 'hasName',
    HAS_PLATFORMS = 'hasPlatforms',
    HAS_RELATIONSHIP_CITATIONS = 'hasRelationshipCitations',
    HAS_PERMISSIONS_REQUIRED = 'hasPermissionsRequired',
    HAS_CAPEC_ID = 'hasCapecId',
    HAS_MTC_ID = 'hasMtcId',
    HAS_ALIASES = 'hasAliases',
    HAS_URL = 'hasUrl',
    HAS_VERSION = 'hasVersion',
    HAS_SYSTEM_REQUIREMENTS = 'hasSystemRequirements',
    HAS_MITIGATORS = 'hasMitigators',
    USES_SOFTWARE = 'usesSoftware',
    USES_TECHNIQUE = 'usesTechnique',
    IS_SUBTECHNIQUE = 'isSubTechnique',
    IS_SUBTECHNIQUE_OF = 'isSubTechniqueOf',
    WAS_CREATED = 'wasCreated',
    WAS_LAST_MODIFIED = 'wasLastModified',
    DATA_TYPE_PROPERTY = 'DatatypeProperty',
    FUNCTIONAL_PROPERTY = 'FunctionalProperty',
    HAS_DEFENSES_BY_PASSED = 'hasDefensesBypassed',
    HAS_ASSOCIATED_GROUPS = 'hasAssociatedGroups',
    HAS_ASSOCIATED_GROUPS_CITATIONS = 'hasAssociatedGroupsCitations',
    HAS_DOMAIN = 'hasDomain',
    HAS_DETECTION = 'hasDetection',
    HAS_SUBTECHNIQUE = 'hasSubTechnique',
    USED_IN_TACTIC = 'usedInTactic'
}

export const mapMalwareData = async(malware: Malware, claims: MalwareClaim[]) => {
    for (const claim of claims) {
        switch (claim.property) {
            case malwarePropertyTypes.TYPE:
                if (claim.value === malwareClassesTypes.TECHNIQUE) {
                    const mitigatorsToMap = await getRelations(malware.id, malwarePropertyTypes.MITIGATES);
                    const mappedMitigators = [] as MappedInfo[];
                    for (const tech of mitigatorsToMap) {
                        console.log(tech);
                        const extractedId = extractId(tech.entity);
                        const mitName = await getName(extractedId);
                        if(!mappedMitigators.find((mit) => mit.id === extractedId)) {
                            mappedMitigators.push({
                                name: mitName.slice(1, -1),
                                id: extractedId,
                                source: DATA_SOURCES.SECURITY_DOMAIN
                            });
                        }
                    }
                    malware[malwarePropertyTypes.HAS_MITIGATORS] = mappedMitigators;
                    const tacticsToMap = await getRelations(malware.id, malwarePropertyTypes.USES_TECHNIQUE);
                    const mappedTactics = [] as MappedInfo[];
                    for (const tac of tacticsToMap) {
                        const extractedId = extractId(tac.entity);
                        const tacName = await getName(extractedId);
                        if(!mappedTactics.find((mit) => mit.id === extractedId)) {
                            mappedTactics.push({
                                name: tacName.slice(1, -1),
                                id: extractedId,
                                source: DATA_SOURCES.SECURITY_DOMAIN
                            });
                        }
                    }
                    console.log(mappedTactics);
                    malware[malwarePropertyTypes.USED_IN_TACTIC] = mappedTactics;
                }
                malware.datatypes.push(extractId(claim.value));
                break;
            case malwarePropertyTypes.DOMAIN:
            case malwarePropertyTypes.RANGE:
                malware.datatypes.push(extractId(claim.value));
                break;
            case malwarePropertyTypes.DATA_TYPE_PROPERTY:
            case malwarePropertyTypes.FUNCTIONAL_PROPERTY:
                malware.datatypes.push(extractId(claim.value));
                break;
            case 'string':
            case 'boolean':
                malware.datatypes.push(extractId(claim.value));
                break;
            case malwarePropertyTypes.HAS_ID:
                const cleanId = claim.value.slice(1, -1);
                const foundSubtechniques = await getSubtechniques(cleanId);
                const mappedTechniques = [];
                for (const tech of foundSubtechniques) {
                    const extractedId = extractId(tech.entity);
                    const techName = await getName(extractedId);
                    mappedTechniques.push({
                        name: techName.slice(1, -1),
                        id: extractedId,
                        source: DATA_SOURCES.SECURITY_DOMAIN
                    });
                }
                malware[malwarePropertyTypes.HAS_SUBTECHNIQUE] = mappedTechniques;
                if (cleanId?.includes('.')) {
                    const cleanedId = cleanId.substring(0, cleanId.indexOf('.'));
                    const foundName = await getName(cleanedId);
                    if (foundName) {
                        malware[malwarePropertyTypes.IS_SUBTECHNIQUE_OF] = {
                            subtechniqueOf: cleanedId,
                            mainTechniqueName: await getName(cleanedId)
                        }
                    }
                } else {
                    malware[malwarePropertyTypes.IS_SUBTECHNIQUE] = false;
                }

                malware[claim.property] = cleanId;
                break;
            case malwarePropertyTypes.HAS_DOMAIN:
            case malwarePropertyTypes.HAS_NAME:
            case malwarePropertyTypes.HAS_VERSION:
            case malwarePropertyTypes.HAS_DESCRIPTION:
            case malwarePropertyTypes.HAS_DETECTION:
            case malwarePropertyTypes.HAS_CAPEC_ID:
            case malwarePropertyTypes.HAS_MTC_ID:
            case malwarePropertyTypes.WAS_CREATED:
            case malwarePropertyTypes.HAS_URL:
            case malwarePropertyTypes.WAS_LAST_MODIFIED:
                malware[claim.property] = claim.value.slice(1, -1);
                break;
            case malwarePropertyTypes.HAS_CONTRIBUTORS:
                const cleanedContributors = claim.value.slice(1, -1);
                // @ts-ignore
                malware[claim.property] = cleanedContributors.split("; ");
                break;
            case malwarePropertyTypes.HAS_ASSOCIATED_GROUPS_CITATIONS:
            case malwarePropertyTypes.HAS_RELATIONSHIP_CITATIONS:
                const cleanedCitations = claim.value.slice(1, -1);
                const relationships = cleanedCitations.split(",");
                const cleanedRelationships = relationships.filter((rel) => rel !== '');
                const mappedRelationships = cleanedRelationships.map((rel) => ({
                    name: rel.slice(10, -1)
                }));
                malware[claim.property] = mappedRelationships;
                break;
            case malwarePropertyTypes.HAS_PLATFORMS:
            case malwarePropertyTypes.HAS_DATA_SOURCES:
            case malwarePropertyTypes.HAS_ALIASES:
            case malwarePropertyTypes.HAS_SYSTEM_REQUIREMENTS:
            case malwarePropertyTypes.HAS_PERMISSIONS_REQUIRED:
            case malwarePropertyTypes.HAS_ASSOCIATED_GROUPS:
                const cleanedClaim = claim.value.slice(1, -1);
                malware[claim.property] = cleanedClaim.split(", ");
                break;
            case malwarePropertyTypes.HAS_DEFENSES_BY_PASSED:
                const cleanedDefenses = claim.value.slice(1, -1);
                const toMapDefenses = cleanedDefenses.split(", ");
                malware[claim.property] = toMapDefenses.map((def) => ({
                    name: def
                }));
                break;
            case malwarePropertyTypes.USES_SOFTWARE:
            case malwarePropertyTypes.USES_TECHNIQUE:
                const loadedName = await loadLabel(claim.value);
                const mappedEntity = {
                    id: claim.value,
                    name: loadedName.slice(1, -1),
                    source: DATA_SOURCES.SECURITY_DOMAIN
                }
                malware[claim.property]?.push(mappedEntity);
                break;
            case malwarePropertyTypes.HAS_SUBTECHNIQUE:
                const subtechniqueId = claim.value.slice(1, -1);
                const subtechniqueName = await getName(claim.value.slice(1, -1));
                if (subtechniqueName) {
                    malware?.[malwarePropertyTypes.HAS_SUBTECHNIQUE]?.push({
                        id: subtechniqueId,
                        name: await getName(subtechniqueId),
                        source: DATA_SOURCES.SECURITY_DOMAIN
                    });
                }
                break;
            case malwarePropertyTypes.IS_SUBTECHNIQUE:
            case malwarePropertyTypes.IS_SUBTECHNIQUE_OF:
                if (malware[malwarePropertyTypes.IS_SUBTECHNIQUE]) {
                    const cleanedId = claim.value.slice(1, -1);
                    const foundName = await getName(cleanedId);
                    if (foundName) {
                        malware[malwarePropertyTypes.IS_SUBTECHNIQUE_OF] = {
                            subtechniqueOf: cleanedId,
                            mainTechniqueName: await getName(cleanedId)
                        }
                    }
                } else {
                    malware[malwarePropertyTypes.IS_SUBTECHNIQUE] = Boolean(claim.value);
                }
                break;
            case malwarePropertyTypes.MITIGATES:
                const cleanedId = claim.value;
                const foundName = await getName(cleanedId);
                malware[malwarePropertyTypes.MITIGATES]?.push({
                    id: cleanedId,
                    name: foundName.slice(1, -1),
                    source: DATA_SOURCES.SECURITY_DOMAIN
                });
                break;
            default:
                return malware;
        }
    }
    // malware.loading = false;
    return malware;
};

export const malwarePropertyEndpointsMap = (property: string): string => {
    switch (property) {
        case malwarePropertyTypes.TYPE:
        case malwarePropertyTypes.DOMAIN:
        case malwarePropertyTypes.RANGE:
            return rdfSchemaSyntax;
        case malwarePropertyTypes.DATA_TYPE_PROPERTY:
        case malwarePropertyTypes.FUNCTIONAL_PROPERTY:
            return owlEndpoint;
        case 'string':
        case 'boolean':
            return xmlSchema;
        case malwareClassesTypes.GROUP:
        case malwareClassesTypes.TECHNIQUE:
        case malwareClassesTypes.TACTIC:
        case malwareClassesTypes.SOFTWARE:
        case malwareClassesTypes.MITIGATION:
        case malwarePropertyTypes.HAS_ID:
        case malwarePropertyTypes.HAS_NAME:
        case malwarePropertyTypes.HAS_URL:
        case malwarePropertyTypes.HAS_VERSION:
        case malwarePropertyTypes.HAS_CONTRIBUTORS:
        case malwarePropertyTypes.HAS_RELATIONSHIP_CITATIONS:
        case malwarePropertyTypes.HAS_DESCRIPTION:
        case malwarePropertyTypes.HAS_PLATFORMS:
        case malwarePropertyTypes.HAS_DATA_SOURCES:
        case malwarePropertyTypes.HAS_DOMAIN:
        case malwarePropertyTypes.HAS_SUBTECHNIQUE:
        case malwarePropertyTypes.HAS_CAPEC_ID:
        case malwarePropertyTypes.WAS_CREATED:
        case malwarePropertyTypes.WAS_LAST_MODIFIED:
        case malwarePropertyTypes.IS_SUBTECHNIQUE:
        case malwarePropertyTypes.HAS_ALIASES:
        case malwarePropertyTypes.IS_SUBTECHNIQUE_OF:
        case malwarePropertyTypes.HAS_SYSTEM_REQUIREMENTS:
        case malwarePropertyTypes.HAS_PERMISSIONS_REQUIRED:
        case malwarePropertyTypes.USES_SOFTWARE:
        case malwarePropertyTypes.USES_TECHNIQUE:
            return feiOntologyEndpoint;
        default:
            return '';
    }
}
